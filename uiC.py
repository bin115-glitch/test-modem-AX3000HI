# Form implementation generated from reading ui file 'UItool.ui'
#
# Created by: PyQt6 UI code generator 6.8.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
import subprocess
import re
import pandas as pd
import threading
import time
import hashlib
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from PyQt6.QtCore import QThread, pyqtSignal
import concurrent.futures
import os
import psutil
import statistics
import shutil
import random
import vlc
import json
from PyQt6.QtWidgets import QMessageBox  # Import QMessageBox for confirmation dialog
import openpyxl
from openpyxl.utils import get_column_letter
class AutoConfThread(QThread):
    log_signal = pyqtSignal(str)

    def __init__(self, ui):
        super().__init__()
        self.ui = ui

    def log_message(self, message):
        self.log_signal.emit(message)

class TestModemThread(QThread):
    log_signal = pyqtSignal(str)  # Tín hiệu để gửi log đến UI
    update_table_signal = pyqtSignal(int, int, str)  # Tín hiệu để cập nhật bảng

    def __init__(self, ui, test_function):
        super().__init__()
        self.ui = ui
        self.test_function = test_function

    def run(self):
        try:
            self.test_function()
        except Exception as e:
            self.log_signal.emit(f"Error during test: {e}")
            with open("error.log", "a", encoding="utf-8") as log_file:
                log_file.write(f"Error in TestModemThread: {e}\n")

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(1065, 655)
        self.tabWidget = QtWidgets.QTabWidget(parent=Dialog)
        self.tabWidget.setGeometry(QtCore.QRect(10, 30, 1031, 591))
        self.tabWidget.setAutoFillBackground(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.MessgaeLog = QtWidgets.QScrollArea(parent=self.tab)
        self.MessgaeLog.setGeometry(QtCore.QRect(710, 290, 300, 261))
        self.MessgaeLog.setWidgetResizable(True)
        self.MessgaeLog.setObjectName("MessgaeLog")
        self.message_log_widget = QtWidgets.QTextEdit(parent=self.MessgaeLog)
        self.message_log_widget.setReadOnly(True)
        self.MessgaeLog.setWidget(self.message_log_widget)
        self.pppusername = QtWidgets.QTextEdit(parent=self.tab)
        self.pppusername.setGeometry(QtCore.QRect(130, 30, 171, 31))
        self.pppusername.setObjectName("pppusername")
        self.pppPass = QtWidgets.QTextEdit(parent=self.tab)
        self.pppPass.setGeometry(QtCore.QRect(130, 70, 171, 31))
        self.pppPass.setObjectName("pppPass")
        self.ESSID_text = QtWidgets.QTextEdit(parent=self.tab)
        self.ESSID_text.setGeometry(QtCore.QRect(130, 110, 171, 31))
        self.ESSID_text.setObjectName("ESSID_text")
        self.PreSharedKey_text = QtWidgets.QTextEdit(parent=self.tab)
        self.PreSharedKey_text.setGeometry(QtCore.QRect(130, 150, 171, 31))
        self.PreSharedKey_text.setObjectName("PreSharedKey_text")
        self.Channel_2G = QtWidgets.QTextEdit(parent=self.tab)
        self.Channel_2G.setGeometry(QtCore.QRect(130, 190, 171, 31))
        self.Channel_2G.setObjectName("Channel_2G")
        self.Channel_5G = QtWidgets.QTextEdit(parent=self.tab)
        self.Channel_5G.setGeometry(QtCore.QRect(130, 230, 171, 31))
        self.Channel_5G.setObjectName("Channel_5G")
        self.MTU = QtWidgets.QTextEdit(parent=self.tab)
        self.MTU.setGeometry(QtCore.QRect(130, 270, 171, 31))
        self.MTU.setObjectName("MTU")
        self.label = QtWidgets.QLabel(parent=self.tab)
        self.label.setGeometry(QtCore.QRect(20, 40, 81, 16))
        self.label.setObjectName("label")
        self.label_2 = QtWidgets.QLabel(parent=self.tab)
        self.label_2.setGeometry(QtCore.QRect(20, 80, 71, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(parent=self.tab)
        self.label_3.setGeometry(QtCore.QRect(20, 120, 71, 16))
        self.label_3.setObjectName("label_3")
        self.label_4 = QtWidgets.QLabel(parent=self.tab)
        self.label_4.setGeometry(QtCore.QRect(20, 150, 81, 16))
        self.label_4.setObjectName("label_4")
        self.label_5 = QtWidgets.QLabel(parent=self.tab)
        self.label_5.setGeometry(QtCore.QRect(20, 190, 71, 16))
        self.label_5.setObjectName("label_5")
        self.label_6 = QtWidgets.QLabel(parent=self.tab)
        self.label_6.setGeometry(QtCore.QRect(20, 230, 71, 16))
        self.label_6.setObjectName("label_6")
        self.label_7 = QtWidgets.QLabel(parent=self.tab)
        self.label_7.setGeometry(QtCore.QRect(20, 270, 71, 16))
        self.label_7.setObjectName("label_7")
        self.Refresh_Button = QtWidgets.QPushButton(parent=self.tab)
        self.Refresh_Button.setGeometry(QtCore.QRect(310, 280, 70, 41))  # Đặt vị trí bên trái nút "Tự động cấu hình"
        self.Refresh_Button.setObjectName("Refresh_Button")
        self.Refresh_Button.setText("Làm mới")
        self.Refresh_Button.clicked.connect(self.refresh_data)
        self.AutoConf_Button = QtWidgets.QPushButton(parent=self.tab)
        self.AutoConf_Button.setGeometry(QtCore.QRect(390, 280, 101, 41))
        self.AutoConf_Button.setObjectName("AutoConf_Button")
        self.AutoConf_Button.clicked.connect(self.autoConf)

        self.pgateway = QtWidgets.QLineEdit(parent=self.tab)
        self.pgateway.setGeometry(QtCore.QRect(130, 370, 111, 31))
        self.pgateway.setPlaceholderText("")
        self.pgateway.setObjectName("pgateway")
        self.pfpt = QtWidgets.QLineEdit(parent=self.tab)
        self.pfpt.setGeometry(QtCore.QRect(130, 420, 111, 31))
        self.pfpt.setPlaceholderText("")
        self.pfpt.setObjectName("pfpt")
        self.p24 = QtWidgets.QLineEdit(parent=self.tab)
        self.p24.setGeometry(QtCore.QRect(130, 470, 111, 31))
        self.p24.setPlaceholderText("")
        self.p24.setObjectName("p24")
        self.pgoogle = QtWidgets.QLineEdit(parent=self.tab)
        self.pgoogle.setGeometry(QtCore.QRect(130, 520, 111, 31))
        self.pgoogle.setPlaceholderText("")
        self.pgoogle.setObjectName("pgoogle")

        self.txtLSgate = QtWidgets.QLineEdit(parent=self.tab)
        self.txtLSgate.setGeometry(QtCore.QRect(240, 370, 41, 31))
        self.txtLSgate.setObjectName("txtLSgate")

        self.txtAGgate = QtWidgets.QLineEdit(parent=self.tab)
        self.txtAGgate.setGeometry(QtCore.QRect(290, 370, 41, 31))
        self.txtAGgate.setObjectName("txtAGgate")

        self.txtLSFPT = QtWidgets.QLineEdit(parent=self.tab)
        self.txtLSFPT.setGeometry(QtCore.QRect(240, 420, 41, 31))
        self.txtLSFPT.setObjectName("txtLSFPT")

        self.txtAGFPT = QtWidgets.QLineEdit(parent=self.tab)
        self.txtAGFPT.setGeometry(QtCore.QRect(290, 420, 41, 31))
        self.txtAGFPT.setObjectName("txtAGFPT")

        self.txtLS24 = QtWidgets.QLineEdit(parent=self.tab)
        self.txtLS24.setGeometry(QtCore.QRect(240, 470, 41, 31))
        self.txtLS24.setObjectName("txtLS24")

        self.txtAG24 = QtWidgets.QLineEdit(parent=self.tab)
        self.txtAG24.setGeometry(QtCore.QRect(290, 470, 41, 31))
        self.txtAG24.setObjectName("txtAG24")

        self.txtLSgool = QtWidgets.QLineEdit(parent=self.tab)
        self.txtLSgool.setGeometry(QtCore.QRect(240, 520, 41, 31))
        self.txtLSgool.setObjectName("txtLSgool")

        self.txtAGgool = QtWidgets.QLineEdit(parent=self.tab)
        self.txtAGgool.setGeometry(QtCore.QRect(290, 520, 41, 31))
        self.txtAGgool.setObjectName("txtAGgool")

        self.txtWiFiLSgate = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiLSgate.setGeometry(QtCore.QRect(340, 370, 41, 31))
        self.txtWiFiLSgate.setObjectName("txtWiFiLSgate")

        self.txtWiFiAGgate = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiAGgate.setGeometry(QtCore.QRect(390, 370, 41, 31))
        self.txtWiFiAGgate.setObjectName("txtWiFiAGgate")

        self.txtWiFiLSFPT = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiLSFPT.setGeometry(QtCore.QRect(340, 420, 41, 31))
        self.txtWiFiLSFPT.setObjectName("txtWiFiLSFPT")

        self.txtWiFiAGFPT = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiAGFPT.setGeometry(QtCore.QRect(390, 420, 41, 31))
        self.txtWiFiAGFPT.setObjectName("txtWiFiAGFPT")

        self.txtWiFiLS24 = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiLS24.setGeometry(QtCore.QRect(340, 470, 41, 31))
        self.txtWiFiLS24.setObjectName("txtWiFiLS24")

        self.txtWiFiAG24 = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiAG24.setGeometry(QtCore.QRect(390, 470, 41, 31))
        self.txtWiFiAG24.setObjectName("txtWiFiAG24")

        self.txtWiFiLSgool = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiLSgool.setGeometry(QtCore.QRect(340, 520, 41, 31))
        self.txtWiFiLSgool.setObjectName("txtWiFiLSgool")

        self.txtWiFiAGgool = QtWidgets.QLineEdit(parent=self.tab)
        self.txtWiFiAGgool.setGeometry(QtCore.QRect(390, 520, 41, 31))
        self.txtWiFiAGgool.setObjectName("txtWiFiAGgool")

        self.chromedriverInput = QtWidgets.QLineEdit(parent=self.tab)
        self.chromedriverInput.setGeometry(QtCore.QRect(550, 330, 150, 31))  # Shifted right by 40
        self.chromedriverInput.setPlaceholderText("")
        self.chromedriverInput.setObjectName("chromedriverInput")
        self.fileIDM = QtWidgets.QLineEdit(parent=self.tab)
        self.fileIDM.setGeometry(QtCore.QRect(550, 380, 150, 31))     # Shifted right by 40
        self.fileIDM.setPlaceholderText("")
        self.fileIDM.setObjectName("fileIDM")
        self.linkdown = QtWidgets.QLineEdit(parent=self.tab)
        self.linkdown.setGeometry(QtCore.QRect(550, 430, 150, 31))    # Shifted right by 40
        self.linkdown.setPlaceholderText("")
        self.linkdown.setObjectName("linkdown")
        self.outputFile = QtWidgets.QLineEdit(parent=self.tab)
        self.outputFile.setGeometry(QtCore.QRect(550, 480, 150, 31))  # Shifted right by 40
        self.outputFile.setPlaceholderText("")
        self.outputFile.setObjectName("outputFile")
        
        self.label_8 = QtWidgets.QLabel(parent=self.tab)
        self.label_8.setGeometry(QtCore.QRect(30, 380, 81, 16))
        
        self.label_8.setObjectName("label_8")
        self.label_9 = QtWidgets.QLabel(parent=self.tab)
        self.label_9.setGeometry(QtCore.QRect(20, 420, 81, 20))
        self.label_9.setObjectName("label_9")
        self.label_10 = QtWidgets.QLabel(parent=self.tab)
        self.label_10.setGeometry(QtCore.QRect(20, 470, 71, 16))
        self.label_10.setObjectName("label_10")
        self.label_11 = QtWidgets.QLabel(parent=self.tab)
        self.label_11.setGeometry(QtCore.QRect(20, 520, 91, 20))
        self.label_11.setObjectName("label_11")
        self.label_12 = QtWidgets.QLabel(parent=self.tab)
        self.label_12.setGeometry(QtCore.QRect(450, 340, 91, 16))     # Shifted right by 40
        self.label_12.setObjectName("label_12")
        self.label_13 = QtWidgets.QLabel(parent=self.tab)
        self.label_13.setGeometry(QtCore.QRect(440, 390, 111, 16))    # Shifted right by 40
        self.label_13.setObjectName("label_13")
        self.label_14 = QtWidgets.QLabel(parent=self.tab)
        self.label_14.setGeometry(QtCore.QRect(440, 440, 111, 16))    # Shifted right by 40
        self.label_14.setObjectName("label_14")
        self.label_18 = QtWidgets.QLabel(parent=self.tab)
        self.label_18.setGeometry(QtCore.QRect(440, 490, 111, 16))    # Shifted right by 40
        self.label_18.setObjectName("label_18")

        self.label_20 = QtWidgets.QLabel(parent=self.tab)
        self.label_20.setGeometry(QtCore.QRect(440, 510, 91, 16))
        self.label_20.setObjectName("label_20")
        
        self.label_21 = QtWidgets.QLabel(parent=self.tab)
        self.label_21.setGeometry(QtCore.QRect(480, 540, 91, 16))
        self.label_21.setObjectName("label_21")

        self.label_22 = QtWidgets.QLabel(parent=self.tab)
        self.label_22.setGeometry(QtCore.QRect(550, 540, 91, 16))
        self.label_22.setObjectName("label_22")

        self.label_23 = QtWidgets.QLabel(parent=self.tab)
        self.label_23.setGeometry(QtCore.QRect(630, 540, 91, 16))
        self.label_23.setObjectName("label_23")

        self.label_24 = QtWidgets.QLabel(parent=self.tab)
        self.label_24.setGeometry(QtCore.QRect(240, 350, 31, 20))
        self.label_24.setObjectName("label_24")

        self.label_25 = QtWidgets.QLabel(parent=self.tab)
        self.label_25.setGeometry(QtCore.QRect(290, 350, 31, 20))
        self.label_25.setObjectName("label_25")

        self.label_26 = QtWidgets.QLabel(parent=self.tab)
        self.label_26.setGeometry(QtCore.QRect(345, 350, 31, 20))
        self.label_26.setObjectName("label_26")

        self.label_27 = QtWidgets.QLabel(parent=self.tab)
        self.label_27.setGeometry(QtCore.QRect(400, 350, 31, 20))
        self.label_27.setObjectName("label_27")

        self.txtpings = QtWidgets.QTextEdit(parent=self.tab)
        self.txtpings.setGeometry(QtCore.QRect(130, 310, 101, 31))
        self.txtpings.setPlaceholderText("")
        self.txtpings.setObjectName("txtpings")
        self.label_16 = QtWidgets.QLabel(parent=self.tab)
        self.label_16.setGeometry(QtCore.QRect(20, 310, 101, 31))
        self.label_16.setObjectName("label_16")
        self.txtTCLan = QtWidgets.QLineEdit(parent=self.tab)
        self.txtTCLan.setGeometry(QtCore.QRect(500, 530, 41, 33))
        self.txtTCLan.setObjectName("txtTCLan")
        self.txtTC2G = QtWidgets.QLineEdit(parent=self.tab)
        self.txtTC2G.setGeometry(QtCore.QRect(580, 530, 41, 33))
        self.txtTC2G.setObjectName("txtTC2G")
        self.txtTC5G = QtWidgets.QLineEdit(parent=self.tab)
        self.txtTC5G.setGeometry(QtCore.QRect(650, 530, 41, 33))
        self.txtTC5G.setObjectName("txtTC5G")

        self.setup_table()

        self.SaveConf_Btn = QtWidgets.QPushButton(parent=self.tab)
        self.SaveConf_Btn.setGeometry(QtCore.QRect(240, 305, 50, 41))
        self.SaveConf_Btn.setObjectName("SaveConf_Btn")
        self.SaveConf_Btn.setText("Lưu")
        self.SaveConf_Btn.clicked.connect(self.saveConf)

        self.TestOneForAll_Button = QtWidgets.QPushButton(parent=self.tab)
        self.TestOneForAll_Button.setGeometry(QtCore.QRect(500, 280, 101, 41))
        self.TestOneForAll_Button.setObjectName("TestOneForAll_Button")
        self.TestOneForAll_Button.clicked.connect(self.start_full)

        self.tabWidget.addTab(self.tab, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")

        self.test_data_table = QtWidgets.QTableWidget(parent=self.tab_2)
        self.test_data_table.setGeometry(QtCore.QRect(10, 10, 1000, 500))
        self.test_data_table.setObjectName("test_data_table")
        self.full_data = Full_data(self, self.test_data_table)  # Pass test_data_table to Full_data
        self.full_data.setup_test_data_table()  # Corrected method call

        self.Refresh_Button_Tab2 = QtWidgets.QPushButton(parent=self.tab_2)
        self.Refresh_Button_Tab2.setGeometry(QtCore.QRect(900, 520, 100, 40))  # Đặt vị trí và kích thước của nút
        self.Refresh_Button_Tab2.setObjectName("Refresh_Button_Tab2")
        self.Refresh_Button_Tab2.setText("Làm mới")
        self.Refresh_Button_Tab2.clicked.connect(self.refresh_tab2_data)

        self.Export_Button_Tab2 = QtWidgets.QPushButton(parent=self.tab_2)
        self.Export_Button_Tab2.setGeometry(QtCore.QRect(780, 520, 100, 40)) 
        self.Export_Button_Tab2.setObjectName("Export_Button_Tab2")
        self.Export_Button_Tab2.setText("Xuất Excel")
        self.Export_Button_Tab2.clicked.connect(self.export_to_excel) 

        self.configurator = test_All(self)  # Pass self (Ui_Dialog) to test_All

        self.tabWidget.addTab(self.tab_2, "")  # Add tab_2 to the tab widget

        self.retranslateUi(Dialog)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        self.update_interval = 10  # Update interval in seconds

        self.configurator = test_All(self)  # Pass self (Ui_Dialog) to test_All

    def saveConf(self):
        """Lưu cấu hình vào file data.json."""
        config_data = {
            "pppusername": self.pppusername.toPlainText(),
            "pppPass": self.pppPass.toPlainText(),
            "ESSID_text": self.ESSID_text.toPlainText(),
            "PreSharedKey_text": self.PreSharedKey_text.toPlainText(),
            "Channel_2G": self.Channel_2G.toPlainText(),
            "Channel_5G": self.Channel_5G.toPlainText(),
            "MTU": self.MTU.toPlainText(),
            "pgateway": self.pgateway.text(),
            "pfpt": self.pfpt.text(),
            "p24": self.p24.text(),
            "pgoogle": self.pgoogle.text(),
            "txtpings": self.txtpings.toPlainText(),
            "txtTCLan": self.txtTCLan.text(),
            "txtTC2G": self.txtTC2G.text(),
            "txtTC5G": self.txtTC5G.text(),
            "txtLSgate": self.txtLSgate.text(),
            "txtAGgate": self.txtAGgate.text(),
            "txtLSFPT": self.txtLSFPT.text(),
            "txtAGFPT": self.txtAGFPT.text(),
            "txtLS24": self.txtLS24.text(),
            "txtAG24": self.txtAG24.text(),
            "txtLSgool": self.txtLSgool.text(),
            "txtAGgool": self.txtAGgool.text(),
            "txtWiFiLSgate": self.txtWiFiLSgate.text(),
            "txtWiFiAGgate": self.txtWiFiAGgate.text(),
            "txtWiFiLSFPT": self.txtWiFiLSFPT.text(),
            "txtWiFiAGFPT": self.txtWiFiAGFPT.text(),
            "txtWiFiLS24": self.txtWiFiLS24.text(),
            "txtWiFiAG24": self.txtWiFiAG24.text(),
            "txtWiFiLSgool": self.txtWiFiLSgool.text(),
            "txtWiFiAGgool": self.txtWiFiAGgool.text(),
            "fileIDM": self.fileIDM.text(),
            "chromedriverInput": self.chromedriverInput.text(),
            "linkdown": self.linkdown.text(),
            "outputFile": self.outputFile.text()
        }

        try:
            with open("data.json", "w", encoding="utf-8") as json_file:
                json.dump(config_data, json_file, ensure_ascii=False, indent=4)
            self.log_message("Cấu hình đã được lưu vào file data.json.")
            
            self.log_message("Khởi động lại chương trình...")
            QtWidgets.QApplication.quit()  # Thoát ứng dụng hiện tại
            QtCore.QProcess.startDetached(sys.executable, sys.argv)  # Khởi động lại ứng dụng
        except Exception as e:
            self.log_message(f"Lỗi khi lưu cấu hình: {e}")

    def loadConf(self):
        """Tải cấu hình từ file data.json và hiển thị trên giao diện."""
        try:
            with open("data.json", "r", encoding="utf-8") as json_file:
                config_data = json.load(json_file)

            self.pppusername.setPlainText(config_data.get("pppusername", ""))
            self.pppPass.setPlainText(config_data.get("pppPass", ""))
            self.ESSID_text.setPlainText(config_data.get("ESSID_text", ""))
            self.PreSharedKey_text.setPlainText(config_data.get("PreSharedKey_text", ""))
            self.Channel_2G.setPlainText(config_data.get("Channel_2G", ""))
            self.Channel_5G.setPlainText(config_data.get("Channel_5G", ""))
            self.MTU.setPlainText(config_data.get("MTU", ""))
            self.pgateway.setText(config_data.get("pgateway", ""))
            self.pfpt.setText(config_data.get("pfpt", ""))
            self.p24.setText(config_data.get("p24", ""))
            self.pgoogle.setText(config_data.get("pgoogle", ""))
            self.txtpings.setPlainText(config_data.get("txtpings", ""))
            self.txtTCLan.setText(config_data.get("txtTCLan", ""))
            self.txtTC2G.setText(config_data.get("txtTC2G", ""))
            self.txtTC5G.setText(config_data.get("txtTC5G", ""))
            self.txtLSgate.setText(config_data.get("txtLSgate", ""))
            self.txtAGgate.setText(config_data.get("txtAGgate", ""))
            self.txtLSFPT.setText(config_data.get("txtLSFPT", ""))
            self.txtAGFPT.setText(config_data.get("txtAGFPT", ""))
            self.txtLS24.setText(config_data.get("txtLS24", ""))
            self.txtAG24.setText(config_data.get("txtAG24", ""))
            self.txtLSgool.setText(config_data.get("txtLSgool", ""))
            self.txtAGgool.setText(config_data.get("txtAGgool", ""))
            self.txtWiFiLSgate.setText(config_data.get("txtWiFiLSgate", ""))
            self.txtWiFiAGgate.setText(config_data.get("txtWiFiAGgate", ""))
            self.txtWiFiLSFPT.setText(config_data.get("txtWiFiLSFPT", ""))
            self.txtWiFiAGFPT.setText(config_data.get("txtWiFiAGFPT", ""))
            self.txtWiFiLS24.setText(config_data.get("txtWiFiLS24", ""))
            self.txtWiFiAG24.setText(config_data.get("txtWiFiAG24", ""))
            self.txtWiFiLSgool.setText(config_data.get("txtWiFiLSgool", ""))
            self.txtWiFiAGgool.setText(config_data.get("txtWiFiAGgool", ""))
            self.fileIDM.setText(config_data.get("fileIDM", r""))
            self.chromedriverInput.setText(config_data.get("chromedriverInput", r""))
            self.linkdown.setText(config_data.get("linkdown", r""))
            self.outputFile.setText(config_data.get("outputFile", r""))

            self.log_message("Cấu hình đã được tải từ file data.json.")
        except FileNotFoundError:
            self.log_message("File data.json không tồn tại. Sử dụng cấu hình mặc định.")
        except Exception as e:
            self.log_message(f"Lỗi khi tải cấu hình: {e}")
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.pppusername.setHtml(_translate("Dialog", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p></body></html>"))
        self.pppusername.setPlaceholderText(_translate("Dialog", "pppUsername"))
        self.pppPass.setPlaceholderText(_translate("Dialog", "pppPassword"))
        self.ESSID_text.setPlaceholderText(_translate("Dialog", "ESSID"))
        self.PreSharedKey_text.setPlaceholderText(_translate("Dialog", "PreSharedKey"))
        self.Channel_2G.setPlaceholderText(_translate("Dialog", "Channel 2.4G"))
        self.Channel_5G.setPlaceholderText(_translate("Dialog", "Channel 5G"))
        self.MTU.setPlaceholderText(_translate("Dialog", "MTU"))
        self.label.setText(_translate("Dialog", "pppUsername"))
        self.label_2.setText(_translate("Dialog", "pppPassword"))
        self.label_3.setText(_translate("Dialog", "ESSID"))
        self.label_4.setText(_translate("Dialog", "PreSharedKey"))
        self.label_5.setText(_translate("Dialog", "Chanel 2.4G"))
        self.label_6.setText(_translate("Dialog", "Channel 5G"))
        self.label_7.setText(_translate("Dialog", "MTU"))
        self.AutoConf_Button.setText(_translate("Dialog", "Tự động cấu hình"))
        self.label_8.setText(_translate("Dialog", "PING Gateway"))
        self.label_9.setText(_translate("Dialog", "PING DNS FPT"))
        self.label_10.setText(_translate("Dialog", "PING 24h.com"))
        self.label_11.setText(_translate("Dialog", "PING DNS google"))
        self.label_12.setText(_translate("Dialog", "File chromedriver"))
        self.label_13.setText(_translate("Dialog", "File IDM"))
        self.label_14.setText(_translate("Dialog", "Link download URL"))
        self.label_18.setText(_translate("Dialog", "File output"))
        self.label_20.setText(_translate("Dialog", "Tiêu chuẩn down:"))
        self.label_21.setText(_translate("Dialog", "Lan: "))
        self.label_22.setText(_translate("Dialog", "2.4Gh: "))
        self.label_23.setText(_translate("Dialog", "5Gh: "))
        self.label_25.setText(_translate("Dialog", "AvgL"))
        self.label_24.setText(_translate("Dialog", "LostL"))

        self.label_27.setText(_translate("Dialog", "AVGW"))
        self.label_26.setText(_translate("Dialog", "LostW"))




        # self.AutoTest_Button.setText(_translate("Dialog", "Test Modem"))
        self.TestOneForAll_Button.setText(_translate("Dialog", "Test tất cả"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("Dialog", "CẤU HÌNH"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("Dialog", "Kết quả chi tiết"))
        self.label_16.setText(_translate("Dialog", "Số lần ping"))
        self.loadConf()
        self.configurator = test_All(self)

    def log_message(self, message):
        self.message_log_widget.append(message)  # Thêm log vào QTextEdit
        self.message_log_widget.moveCursor(QtGui.QTextCursor.MoveOperation.End)  # Đưa con trỏ đến cuối
        self.message_log_widget.ensureCursorVisible()  # Đảm bảo dòng cuối cùng hiển thị
        QtWidgets.QApplication.processEvents()  # Cập nhật giao diện ngay lập tức
    
    def get_gateway_mac_address(self):
        """Retrieve the MAC address of the gateway."""
        try:
            result = subprocess.run(['arp', '-a'], stdout=subprocess.PIPE, text=True)
            output = result.stdout
            mac_address = re.findall(r'([0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2})', output)
            if mac_address:
                self.log_message(f"MAC address found: {mac_address[0]}")
                return mac_address[0].replace('-', '').upper()
            else:
                self.log_message("No MAC address found in ARP table.")
                return None
        except Exception as e:
            self.log_message(f"Error retrieving MAC address: {e}")
            return None

    def getSSID(self):
        ssid = self.ESSID_text.toPlainText()
        password = self.PreSharedKey_text.toPlainText()
        channel = self.Channel_2G.toPlainText()
        channel5G = self.Channel_5G.toPlainText()
        pppUserName = self.pppusername.toPlainText()
        pppPassword = self.pppPass.toPlainText()
        MTU = self.MTU.toPlainText()
        return ssid, password, channel, channel5G, pppUserName, pppPassword, MTU


    def reset(self):
        self.results_data = []
        self.concludeLan = ""
        self.concludeWIFI5 = ""
        self.concludeWIFI2 = ""
        self.result_ping = None
        self.result_download = None
        self.ui.log_message("Đã đặt lại trạng thái của test_All.")

    def refresh_data(self):
        self.Table_wf.clearContents()
        self.message_log_widget.clear()
        self.log_message("Dữ liệu đã được làm mới.")
        self.populate_table_headers()
    def refresh_tab2_data(self):
        """Làm mới dữ liệu trong bảng test_data_table và xóa dữ liệu trong results_data.json."""
        # Xóa nội dung bảng
        self.test_data_table.clearContents()
        
        # Xóa dữ liệu trong file results_data.json
        try:
            with open('results_data.json', 'w', encoding='utf-8') as json_file:
                json.dump([], json_file, ensure_ascii=False, indent=4)  # Ghi mảng rỗng vào file
            self.log_message("Dữ liệu trong results_data.json đã được xóa.")
        except Exception as e:
            self.log_message(f"Lỗi khi xóa dữ liệu trong results_data.json: {e}")
        
        # Làm mới bảng
        self.full_data.setup_test_data_table()
        self.log_message("Dữ liệu trong tab 2 đã được làm mới.")




    def start_testAll_thread(self):
        # Vô hiệu hóa nút "Lưu" khi bắt đầu
        self.SaveConf_Btn.setEnabled(False)

        # Kiểm tra và dừng luồng cũ nếu đang chạy
        if hasattr(self, 'testAll_thread') and self.testAll_thread.isRunning():
            self.testAll_thread.terminate()
            self.testAll_thread.wait()

        # Làm mới dữ liệu trước khi bắt đầu
        self.refresh_data()

        # Tạo luồng mới và kết nối tín hiệu
        self.testAll_thread = TestModemThread(self, self.configurator.testAll)
        self.testAll_thread.log_signal.connect(self.log_message)  # Kết nối tín hiệu log

        # Kích hoạt lại nút "Lưu" khi hoàn tất
        self.testAll_thread.finished.connect(lambda: self.SaveConf_Btn.setEnabled(True))

        self.testAll_thread.start()
    def start_full(self):
        # Kiểm tra và dừng luồng cũ nếu đang chạy
        if hasattr(self, 'testAll_thread') and self.testAll_thread.isRunning():
            self.testAll_thread.terminate()
            self.testAll_thread.wait()

        # Làm mới dữ liệu trước khi bắt đầu
        self.refresh_data()

        # Tạo luồng mới và kết nối tín hiệu
        self.testAll_thread = TestModemThread(self, self.configurator.config_testAll)
        self.testAll_thread.log_signal.connect(self.log_message)  # Kết nối tín hiệu log
        self.testAll_thread.start() 

    def autoConf(self):
        """Chạy cấu hình tự động trong một luồng riêng biệt."""
        self.testAll_thread = TestModemThread(self, self.configurator.configure)
        self.testAll_thread.log_signal.connect(self.log_message)  # Kết nối tín hiệu log
        self.testAll_thread.start() 


    def stop_test(self):
        self.ui.log_message("Test đã bị dừng.")
        # Add any additional cleanup logic here if needed
        raise Exception("Test stopped by user or due to an error.")

    def populate_table_headers(self):
    # Thiết lập các giá trị tiêu đề cho bảng Table_wf
        self.Table_wf.setItem(0, 0, QtWidgets.QTableWidgetItem('MAC'))
        self.Table_wf.item(0, 0).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        self.Table_wf.setItem(0, 1, QtWidgets.QTableWidgetItem(' TX'))
        self.Table_wf.item(0, 1).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        self.Table_wf.setItem(0, 2, QtWidgets.QTableWidgetItem(' Số lần kiểm tra'))

        self.Table_wf.setItem(0, 3, QtWidgets.QTableWidgetItem('LAN'))
        self.Table_wf.setItem(0, 5, QtWidgets.QTableWidgetItem('WIFI'))
        self.Table_wf.setItem(1, 3, QtWidgets.QTableWidgetItem('Ping time'))
        self.Table_wf.setItem(1, 4, QtWidgets.QTableWidgetItem('Down Rate (Mbps)'))
        self.Table_wf.setItem(1, 5, QtWidgets.QTableWidgetItem('Ping time'))
        self.Table_wf.setItem(1, 6, QtWidgets.QTableWidgetItem('Down Rate (Mbps)'))
        self.Table_wf.setItem(2, 6, QtWidgets.QTableWidgetItem('2.4G'))
        self.Table_wf.setItem(2, 7, QtWidgets.QTableWidgetItem('5G'))
        self.Table_wf.setItem(0, 8, QtWidgets.QTableWidgetItem('VLC'))
        self.Table_wf.setItem(1, 9, QtWidgets.QTableWidgetItem('Độ ổn định'))
        self.Table_wf.setItem(1, 9, QtWidgets.QTableWidgetItem('Xem nhiều kênh một lúc'))
        self.Table_wf.setItem(1, 8, QtWidgets.QTableWidgetItem('Độ ổn định'))
        self.Table_wf.setItem(0, 10, QtWidgets.QTableWidgetItem('Kết luận'))
        self.Table_wf.setColumnWidth(0, 120)  # Đặt kích thước tối thiểu nếu cần

        for i in [3, 4, 5]:
            self.Table_wf.setItem(i, 2, QtWidgets.QTableWidgetItem('Lần ' + str(i - 2)))

        # Hiển thị tiêu đề hàng và cột
        self.Table_wf.verticalHeader().setVisible(True)
        self.Table_wf.horizontalHeader().setVisible(True)

        for i in range(self.Table_wf.rowCount()):
            for j in range(self.Table_wf.columnCount()):
                item = self.Table_wf.item(i, j)
                if item:
                    item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa

    def setup_table(self):
        self.Table_wf = QtWidgets.QTableWidget(6, 13, parent=self.tab)  # 4 rows x 11 columns
        self.Table_wf.setGeometry(QtCore.QRect(320, 10, 691, 261))  # Maintain original position & size
        self.Table_wf.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
        self.Table_wf.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.SizeAdjustPolicy.AdjustToContentsOnFirstShow)
        self.Table_wf.setObjectName("Table_wf")

        self.Table_wf.setSpan(0, 2, 3, 1)  # "Số lần kiểm tra"
        self.Table_wf.setSpan(0, 0, 3, 1)  # "Mac"
        self.Table_wf.setSpan(0, 1, 3, 1)  # "TX"

        self.Table_wf.setSpan(0, 3, 1, 2)  # "LAN"
        self.Table_wf.setSpan(0, 5, 1, 3)  # "WIFI"
        self.Table_wf.setSpan(0, 8, 1, 2)  # "VLC"

        # Adjust spans for sub-columns under WIFI
        self.Table_wf.setSpan(1, 3, 2, 1)  # "Ping time"
        self.Table_wf.setSpan(1, 4, 2, 1)  # "Down Rate (Mbps)"
        self.Table_wf.setSpan(1, 5, 2, 1)  # "Ping time"
        self.Table_wf.setSpan(1, 6, 1, 2)  # "Kết luận"

        # Adjust spans for sub-columns under WIFI
        self.Table_wf.setSpan(1, 7, 2, 1)  
        self.Table_wf.setSpan(1, 8, 2, 1)  
        self.Table_wf.setSpan(1, 9, 2, 1)  
        self.Table_wf.setSpan(0, 10, 3, 1)  

        self.Table_wf.setSpan(3, 1, 3, 1)
        self.Table_wf.setSpan(3, 0, 3, 1)
        for i in range(11):
            self.Table_wf.setColumnWidth(i, 65)

        for i in [3, 4, 5]:
            self.Table_wf.setRowHeight(i, 50)

        self.populate_table_headers()

        # Center-align all cells in the table
        for row in range(self.Table_wf.rowCount()):
            for col in range(self.Table_wf.columnCount()):
                item = self.Table_wf.item(row, col)
                if not item:
                    item = QtWidgets.QTableWidgetItem()  # Create an empty item if none exists
                    self.Table_wf.setItem(row, col, item)
                item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
    
    def export_to_excel(self):
        """Ghi dữ liệu từ results_data.json vào file Excel Book1.xlsx."""
        try:
            # Đọc dữ liệu từ file JSON
            json_file_path = 'results_data.json'
            with open(json_file_path, 'r', encoding='utf-8') as json_file:
                data = json.load(json_file)

            # Mở file Excel
            excel_file_path = r'Book1.xlsx'
            workbook = openpyxl.load_workbook(excel_file_path)
            sheet = workbook.active

            # Tìm dòng đã tồn tại của MAC Address
            def find_row_by_mac(mac_address):
                for row in range(6, sheet.max_row + 1):  # Bắt đầu từ dòng 6
                    if sheet[f"B{row}"].value == mac_address:
                        return row
                return None

            # Ghi dữ liệu vào các cột tương ứng
            def write_data_to_columns(entry, row, base_col, ping_key, download_key):
                connection_type = entry["Connection Type"]
                column_map = {
                    "LAN": {"ping": base_col, "download": base_col + 1,"Tx Power": 3, "Stability": 19, "Watch multiple channels": 20},
                    "5G": {"ping": base_col + 2, "download": base_col + 4},
                    "2.4G": {"download": base_col + 3, "Conclude All":21}
                }

                if connection_type in column_map:
                    if "ping" in column_map[connection_type]:
                        col_ping = column_map[connection_type]["ping"]
                        col_ping_letter = get_column_letter(col_ping)
                        sheet[f"{col_ping_letter}{row}"] = entry.get(ping_key, "N/A")

                    if "download" in column_map[connection_type]:
                        col_download = column_map[connection_type]["download"]
                        col_download_letter = get_column_letter(col_download)
                        sheet[f"{col_download_letter}{row}"] = entry.get(download_key, "N/A")
                    
                    if "Tx Power" in column_map[connection_type]:
                        col_stability = column_map[connection_type]["Tx Power"]
                        col_stability_letter = get_column_letter(col_stability)
                        sheet[f"{col_stability_letter}{row}"] = entry.get("Tx Power", "N/A")

                    if "Stability" in column_map[connection_type]:
                        col_stability = column_map[connection_type]["Stability"]
                        col_stability_letter = get_column_letter(col_stability)
                        sheet[f"{col_stability_letter}{row}"] = entry.get("Stability", "N/A")

                    # Ghi dữ liệu Watch multiple channels (nếu có)
                    if "Watch multiple channels" in column_map[connection_type]:
                        col_watch = column_map[connection_type]["Watch multiple channels"]
                        col_watch_letter = get_column_letter(col_watch)
                        sheet[f"{col_watch_letter}{row}"] = entry.get("Watch multiple channels", "N/A")
                    
                    if "Conclude All" in column_map[connection_type]:
                        col_watch = column_map[connection_type]["Conclude All"]
                        col_watch_letter = get_column_letter(col_watch)
                        sheet[f"{col_watch_letter}{row}"] = entry.get("Conclude All", "N/A")

            # Ghi dữ liệu vào file Excel
            for entry in data:
                mac_address = entry["MAC Address"]
                row = find_row_by_mac(mac_address)
                if row is None:
                    row = sheet.max_row + 1
                    sheet[f"B{row}"] = mac_address


                write_data_to_columns(entry, row, base_col=4, ping_key="Ping Result 1", download_key="Download Speed 1 (Mbps)")
                write_data_to_columns(entry, row, base_col=9, ping_key="Ping Result 2", download_key="Download Speed 2 (Mbps)")
                write_data_to_columns(entry, row, base_col=14, ping_key="Ping Result 3", download_key="Download Speed 3 (Mbps)")

            # Lưu file Excel
            workbook.save(excel_file_path)
            self.log_message(f"Dữ liệu đã được ghi vào file Excel: {excel_file_path}")
        except Exception as e:
            self.log_message(f"Lỗi khi ghi dữ liệu vào file Excel: {e}")
class Full_data:
    def __init__(self, ui, test_data_table):
        self.ui = ui
        self.test_data_table = test_data_table  # Use the passed test_data_table
        self.data_frame = None

    def setup_test_data_table(self):
        self.test_data_table.setColumnCount(39)
        self.test_data_table.setRowCount(200)
        self.test_data_table.setWordWrap(True)

        for i in range(2, self.test_data_table.columnCount()):
            self.test_data_table.setColumnWidth(i, 50)

        self.test_data_table.setColumnWidth(0, 30)

        a = ['STT', 'MAC', 'Power', 'Kết luận', 'Ghi chú']
        a_index = 0
        for i in [0, 1, 2, 20, 21]:
            self.test_data_table.setSpan(0, i, 5, 1)
            self.test_data_table.setItem(0, i, QtWidgets.QTableWidgetItem(a[a_index]))
            a_index += 1

        for i in [3, 8, 13]:
            index = int((i + 9) / 7)
            self.test_data_table.setSpan(0, i, 1, 5)
            self.test_data_table.setItem(0, i, QtWidgets.QTableWidgetItem('Lần ' + str(index)))
            self.test_data_table.setSpan(1, i, 1, 2)
            self.test_data_table.setItem(1, i, QtWidgets.QTableWidgetItem('LAN'))

        self.test_data_table.setSpan(0, 18, 2, 2)
        self.test_data_table.setItem(0, 18, QtWidgets.QTableWidgetItem('IPTV'))

        for i in [5, 10, 15]:
            self.test_data_table.setSpan(1, i, 1, 3)
            self.test_data_table.setItem(1, i, QtWidgets.QTableWidgetItem('WIFI'))

        for i in [6, 11, 16]:
            self.test_data_table.setSpan(2, i, 1, 2)
            self.test_data_table.setItem(2, i, QtWidgets.QTableWidgetItem('Down Rate'))

        b = [
            'Ping time', 'Down rate', 'Ping time',
            'Ping time', 'Down rate', 'Ping time',
            'Ping time', 'Down rate', 'Ping time',
            'Độ ổn định', 'Xem nhiều kênh một lúc'
        ]
        b_index = 0
        indices = [3, 4, 5, 8, 9, 10, 13, 14, 15, 18, 19,20,21,22, 23, 24]

        # Ensure the loop does not exceed the length of `b`
        for i in indices[:len(b)]:
            self.test_data_table.setSpan(2, i, 3, 1)
            self.test_data_table.setItem(2, i, QtWidgets.QTableWidgetItem(b[b_index]))
            b_index += 1

        c = ['RSSI - 40dBm', 'RSSI - 55dBm', 'RSSI - 40dBm', 'RSSI - 55dBm', 'RSSI - 40dBm', 'RSSI - 55dBm']
        d = ['2.4G', '5G', '2.4G', '5G', '2.4G', '5G']
        cd_index = 0
        for i in [6, 7, 11, 12, 16, 17]:
            self.test_data_table.setItem(3, i, QtWidgets.QTableWidgetItem(c[cd_index]))
            self.test_data_table.setItem(4, i, QtWidgets.QTableWidgetItem(d[cd_index]))
            cd_index += 1

        self.test_data_table.setRowHeight(3, 50)

        for i in [6, 12, 16, 22, 26]:
            self.test_data_table.setColumnWidth(i, 70)
    
        # Load data from JSON and populate the table
        def load_json_data():
            try:
                with open('results_data.json', 'r', encoding='utf-8') as json_file:
                    data = json.load(json_file)

                mac_row_map = {}  # Map MAC Address to row index
                current_row = 5  # Start populating data from row 5

                for entry in data:
                    mac_address = entry.get("MAC Address", "N/A")
                    if mac_address not in mac_row_map:
                        mac_row_map[mac_address] = current_row
                        self.test_data_table.setItem(current_row, 0, QtWidgets.QTableWidgetItem(str(current_row - 4)))  # STT
                        self.test_data_table.setItem(current_row, 1, QtWidgets.QTableWidgetItem(mac_address))  # MAC
                        current_row += 1

                    row = mac_row_map[mac_address]
                    connection_type = entry.get("Connection Type", "N/A")

                    # Determine the column offset for each "Lần"
                    if connection_type == "LAN":
                        for i, col_offset in enumerate([3, 8, 13]):  # Lần 1, Lần 2, Lần 3
                            self.test_data_table.setItem(row, col_offset, QtWidgets.QTableWidgetItem(entry.get(f"Ping Result {i + 1}", "N/A")))
                            self.test_data_table.setItem(row, col_offset + 1, QtWidgets.QTableWidgetItem(str(entry.get(f"Download Speed {i + 1} (Mbps)", "N/A"))))
                            self.test_data_table.setItem(row, 18, QtWidgets.QTableWidgetItem(entry.get("Stability", "N/A")))
                            self.test_data_table.setItem(row, 19, QtWidgets.QTableWidgetItem(entry.get("Watch multiple channels", "N/A")))
                            self.test_data_table.setItem(row, 2, QtWidgets.QTableWidgetItem(entry.get("Tx Power", "N/A")))



                    elif connection_type == "2.4G":
                        for i, col_offset in enumerate([6, 11, 16]):  # Lần 1, Lần 2, Lần 3
                            self.test_data_table.setItem(row, col_offset, QtWidgets.QTableWidgetItem(str(entry.get(f"Download Speed {i + 1} (Mbps)", "N/A"))))
                            self.test_data_table.setItem(row, 20, QtWidgets.QTableWidgetItem(entry.get("Conclude All", "N/A")))


                    elif connection_type == "5G":
                        for i, col_offset in enumerate([7, 12, 17]):  # Lần 1, Lần 2, Lần 3
                            self.test_data_table.setItem(row, col_offset-2, QtWidgets.QTableWidgetItem(entry.get(f"Ping Result {i + 1}", "N/A")))
                            self.test_data_table.setItem(row, col_offset, QtWidgets.QTableWidgetItem(str(entry.get(f"Download Speed {i + 1} (Mbps)", "N/A"))))

            except FileNotFoundError:
                print("results_data.json not found.")
            except json.JSONDecodeError:
                print("Error decoding JSON from results_data.json.")
            except Exception as e:
                print(f"An error occurred: {e}")
        self.refresh_timer = QtCore.QTimer()
        self.refresh_timer.timeout.connect(load_json_data)
        self.refresh_timer.start(10000)  # Refresh every 5 seconds

        # Initial load
        load_json_data()

        for row in range(self.test_data_table.rowCount()):
            for col in range(self.test_data_table.columnCount()):
                item = self.test_data_table.item(row, col)
                if item:
                    item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa

class test_All:
    def __init__(self, ui):
        self.ui = ui
        self.test_data_table = ui.test_data_table  # Ensure test_data_table is initialized
        gateway_ip = self.get_gateway()
        self.servers = [gateway_ip, self.ui.pgoogle.text(), self.ui.p24.text(), self.ui.pfpt.text()]
        self.concludeAll = ""
        self.result_download = ""
        self.server_standards_l = {
            gateway_ip: {'loss': int(self.ui.txtLSgate.text() or 0), 'avg': int(self.ui.txtAGgate.text() or 0)},
            self.ui.pgoogle.text(): {'loss': int(self.ui.txtLSgool.text() or 0), 'avg': int(self.ui.txtAGgool.text() or 0)},
            self.ui.p24.text(): {'loss': int(self.ui.txtLS24.text() or 0), 'avg': int(self.ui.txtAG24.text() or 0)},
            self.ui.pfpt.text(): {'loss': int(self.ui.txtLSFPT.text() or 0), 'avg': int(self.ui.txtAGFPT.text() or 0)}
        }
        self.server_standards_w = {
            gateway_ip: {'loss': int(self.ui.txtWiFiLSgate.text() or 0), 'avg': int(self.ui.txtWiFiAGgate.text() or 0)},
            self.ui.pgoogle.text(): {'loss': int(self.ui.txtWiFiLSgool.text() or 0), 'avg': int(self.ui.txtWiFiAGgool.text() or 0)},
            self.ui.p24.text(): {'loss': int(self.ui.txtWiFiLS24.text() or 0), 'avg': int(self.ui.txtWiFiAG24.text() or 0)},
            self.ui.pfpt.text(): {'loss': int(self.ui.txtWiFiLSFPT.text() or 0), 'avg': int(self.ui.txtWiFiAGFPT.text() or 0)}
        }
        self.result_ping = None
        self.result_down_lan = None
        self.output_path = os.path.normpath(self.ui.fileIDM.text())

        self.output_file_name = "NEW_AUDITION_FULL_5.80.zip"
        self.standard_speed = 10
        
        self.hd_url_1 = self.get_random_url('SourcesFHD.txt')  
        self.hd_url_2 = self.get_random_url('SourcesFHD.txt')
        self.sd_url = self.get_random_url('SourcesSD.txt')
        self.results_data = []
        self.concludeLan = ""
        self.concludeWIFI5 = ""
        self.concludeWIFI2 = ""
        self.Tx_Power = ""	
        self.mac_address=""
        self.successful_urls = 0  # Biến đếm số URL mở thành công

    def get_int_value(self, field, default=0):
        """Fetch integer value from QLineEdit."""
        try:
            # Ensure the field is not empty and fetch its value
            value = field.text().strip()
            if value:
                value = int(value)  # Convert to integer
                self.ui.log_message(f"Fetching value from field: {field.objectName()}, Value: {value}")
                return value
            else:
                self.ui.log_message(f"Field {field.objectName()} is empty, using default: {default}")
                return default
        except ValueError:
            self.ui.log_message(f"Invalid value in field: {field.objectName()}, using default: {default}")
            return default

    def get_random_url(self,file_path):
        try:
            with open(file_path, 'r') as file:
                urls = file.readlines()
            urls = [url.strip().replace(',', '').replace("'", '') for url in urls if url.strip()]  # Loại bỏ dòng trống
            if not urls:  
                raise ValueError("Danh sách URL trong tệp rỗng hoặc không hợp lệ.")
            return random.choice(urls)
        except FileNotFoundError:
            self.ui.log_message(f"Lỗi: Không tìm thấy tệp tại đường dẫn {file_path}.")
            raise
        except Exception as e:
            self.ui.log_message(f"Lỗi: {e}")
            raise
    def md5_encrypt(self, input_string):
        md5_hash = hashlib.md5()
        md5_hash.update(input_string.encode('utf-8'))
        return md5_hash.hexdigest()  # Trả về chuỗi hexadecimal của hash

    def configure(self):
        self.ui.log_message("Configuration started.")
        self.mac_address = self.ui.get_gateway_mac_address()

        if (self.mac_address):
            password = self.md5_encrypt(self.mac_address)[:10].upper()
            self.ui.log_message(f"Generated Password: {password}")
        else:
            self.ui.log_message("MAC address not found.")
            return

        chromedriver_path = self.ui.chromedriverInput.text()  # Use text() instead of toPlainText()
        ssidnew, passnew, channel, channel5G, pppUserName, pppPassword, MTU = self.ui.getSSID()

        chrome_options = Options()
        chrome_options.add_argument("--start-maximized")
        chrome_options.add_argument("--ignore-certificate-errors")
        chrome_options.add_argument("--disable-logging")
        chrome_options.add_argument("--log-level=3")

        try:
            service = Service(chromedriver_path)
            driver = webdriver.Chrome(service=service, options=chrome_options)
        except Exception as e:
            self.ui.log_message(f"Error initializing WebDriver: {e}")
            return

        try:
            driver.get("http://192.168.1.1/")
            WebDriverWait(driver, 30).until(EC.visibility_of_element_located((By.ID, "username")))
            WebDriverWait(driver, 30).until(EC.visibility_of_element_located((By.ID, "password")))

            driver.find_element(By.ID, "username").send_keys("admin")
            password_field = driver.find_element(By.ID, "password")
            password_field.send_keys(password)
            password_field.send_keys(Keys.RETURN)
            time.sleep(5)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "header")))
        except Exception as e:
            self.ui.log_message(f"Error during login: {e}")
            driver.quit()
            return

        try:
            time.sleep(5)
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.LINK_TEXT, "Status"))).click()
            # Chuyển vào frame "main"
            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "main")))
            # Lấy giá trị Tx Power
            tx_label = driver.find_element(By.XPATH, "//td[contains(text(), 'Tx Power')]")
            tx_value_td = tx_label.find_element(By.XPATH, "./following-sibling::td[1]")
            value = tx_value_td.text.strip()
            self.Tx_Power = value
            # Quay lại trang chính để click menu tiếp theo
            time.sleep(2)
            driver.switch_to.default_content()
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "header")))
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.LINK_TEXT, "Network"))).click()
            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "nav")))
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.LINK_TEXT, "Internet"))).click()
            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "main")))
            username_field = WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.ID, "pppUserName")))
            username_field.click()
            username_field.clear()
            username_field.send_keys(pppUserName)
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.XPATH, '//*[@id="secPppoeItems"]/table[2]/tbody/tr[2]'))).click()

            password_field = driver.find_element(By.ID, "pppPassword")
            password_field.click()
            password_field.clear()
            password_field.send_keys(pppPassword)

            mtu_field = driver.find_element(By.ID, "MTU")
            mtu_field.click()
            mtu_field.clear()
            mtu_field.send_keys(MTU)
            time.sleep(2)
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, "btnOK"))).click()

            try:
                WebDriverWait(driver, 5).until(EC.alert_is_present())
                alert = driver.switch_to.alert
                self.ui.log_message(f"Alert xuất hiện: {alert.text}")
                alert.accept()
            except Exception as e:
                self.ui.log_message(f"Không có alert nào xuất hiện: {e}")

            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "nav")))
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.LINK_TEXT, "Wi-Fi Advanced"))).click()
            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "nav")))
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.LINK_TEXT, "Host SSID"))).click()
            driver.switch_to.default_content()
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "main")))
            time.sleep(2)
            essid_field = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.NAME, "ESSID")))
            essid_field.click()
            essid_field.clear()
            essid_field.send_keys(ssidnew + '2')
            time.sleep(2)
            pre_shared_key_field = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.NAME, "PreSharedKey")))
            pre_shared_key_field.click()
            pre_shared_key_field.send_keys(Keys.CONTROL, 'a')
            pre_shared_key_field.send_keys(Keys.BACKSPACE)
            pre_shared_key_field.send_keys(passnew)
            time.sleep(2)
            essid_field_5g = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.NAME, "ESSID_5g")))
            essid_field_5g.click()
            essid_field_5g.clear()
            essid_field_5g.send_keys(ssidnew + '5')
            time.sleep(2)
            pre_shared_key_field_5g = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.NAME, "PreSharedKey_5g")))
            pre_shared_key_field_5g.click()
            pre_shared_key_field_5g.send_keys(Keys.CONTROL, 'a')
            pre_shared_key_field_5g.send_keys(Keys.BACKSPACE)
            pre_shared_key_field_5g.send_keys(passnew)
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.NAME, "SaveBtn"))).click()           
            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "nav")))
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.LINK_TEXT, "Wi-Fi Advanced"))).click()
            driver.switch_to.default_content()
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.frame_to_be_available_and_switch_to_it((By.NAME, "main")))
            wlan_channel_bandwidth_select = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.NAME, "WLANChannelBandwidth")))
            select = Select(wlan_channel_bandwidth_select)
            select.select_by_value("2")
            select.select_by_visible_text("20 MHz")
            select.select_by_index(0)

            wlan_channel_bandwidth_select_5g = WebDriverWait(driver, 5).until(EC.element_to_be_clickable((By.NAME, "WLANChannelBandwidth_5g")))
            wlan_channel_bandwidth_select_5g.click()
            wlan_channel_bandwidth_select_5g.send_keys("20/40/80/160 MHz")
            time.sleep(2)
            WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.NAME, "SaveBtn"))).click()
            self.ui.Table_wf.setItem(3, 0, QtWidgets.QTableWidgetItem(str(self.mac_address)))
            self.ui.Table_wf.setItem(3, 1, QtWidgets.QTableWidgetItem(str(self.Tx_Power)))
            self.ui.Table_wf.item(3, 0).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.item(3, 1).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa

        except Exception as e:
            self.ui.log_message(f"Error during configuration: {e}")
        finally:
            driver.quit()
            self.ui.log_message("Cấu hình thành công.")

    def get_gateway(self):
        try:
            output = subprocess.check_output("route print", shell=True, text=True)
            match = re.search(r'\s*0.0.0.0\s+0.0.0.0\s+([0-9.]+)', output)
            if match:
                return match.group(1)

        except subprocess.CalledProcessError as e:
            self.ui.log_message(f"Error: Command execution failed. {e}")
        except Exception as e:
            self.ui.log_message(f"An error occurred: {e}")

        return None
    
    def enable_wifi(self):
        result = subprocess.run('netsh interface set interface "Wi-Fi" admin=enable', capture_output=True, text=True, shell=True)
        if result.returncode != 0:
            self.ui.log_message(f"Lỗi khi bật Wi-Fi: {result.stderr}")
        else:
             self.ui.log_message("Wi-Fi đã được bật.")
    
    def disable_network_adapter(self,adapter_name):
        try:
            subprocess.run(f'netsh interface set interface "{adapter_name}" admin=disable', check=True, shell=True)
            self.ui.log_message(f"{adapter_name} đã bị tắt.")
        except subprocess.CalledProcessError:
            self.ui.log_message("Lỗi khi tắt card mạng.")
    def check_and_enable_wifi(self):
        result = subprocess.run('netsh interface show interface "Wi-Fi"', capture_output=True, text=True, shell=True)
        if result.returncode != 0:
            self.ui.log_message(f"Error checking Wi-Fi: {result.stderr}")
            return
        
        if "Disabled" in result.stdout:
            self.ui.log_message("Wi-Fi is disabled, enabling it...")
            self.enable_wifi()  
        else:
            self.ui.log_message("Wi-Fi is already enabled.")

    def get_network_adapters(self):
        result = subprocess.run('netsh interface show interface', capture_output=True, text=True, shell=True)
        interfaces = []

        for line in result.stdout.splitlines():
            if 'Connected' in line:
                interface_name = line.split()[3]
                interfaces.append(interface_name)

        return interfaces
    def enable_network_adapter(self,adapter_name):
        try:
            subprocess.run(f'netsh interface set interface "{adapter_name}" admin=enable', check=True, shell=True)
            self.ui.log_message(f"{adapter_name} đã được bật lại.")
        except subprocess.CalledProcessError:
            self.ui.log_message("Lỗi khi bật lại card mạng.")

    def check_and_enable_ethernet(self):
        adapters = self.get_network_adapters()
        ethernet_adapter = "Ethernet" 
        if ethernet_adapter not in adapters:
            self.ui.log_message("Ethernet is not connected.")
            self.enable_network_adapter(ethernet_adapter)
        else:
            self.ui.log_message("Ethernet is already connected.")
    def connect_wifi(self, ssid, password):
        # Create a Wi-Fi profile XML
        profile_xml = f"""
        <WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
            <name>{ssid}</name>
            <SSIDConfig>
                <SSID>
                    <name>{ssid}</name>
                </SSID>
            </SSIDConfig>
            <connectionType>ESS</connectionType>
            <connectionMode>auto</connectionMode>
            <MSM>
                <security>
                    <authEncryption>
                        <authentication>WPA2PSK</authentication>
                        <encryption>AES</encryption>
                        <useOneX>false</useOneX>
                    </authEncryption>
                    <sharedKey>
                        <keyType>passPhrase</keyType>
                        <protected>false</protected>
                        <keyMaterial>{password}</keyMaterial>
                    </sharedKey>
                </security>
            </MSM>
        </WLANProfile>
        """

        # Save the profile to a temporary file
        profile_path = os.path.join(os.getenv("TEMP"), f"{ssid}.xml")
        try:
            with open(profile_path, "w") as profile_file:
                profile_file.write(profile_xml)

            # Add the profile
            add_profile_command = f'netsh wlan add profile filename="{profile_path}"'
            add_profile_result = subprocess.run(add_profile_command, capture_output=True, text=True, shell=True)
            if add_profile_result.returncode != 0:
                self.ui.log_message(f"Failed to add Wi-Fi profile: {add_profile_result.stderr}")
                return

            # Connect to the Wi-Fi network
            connect_command = f'netsh wlan connect name="{ssid}"'
            connect_result = subprocess.run(connect_command, capture_output=True, text=True, shell=True)
            if connect_result.returncode != 0:
                self.ui.log_message(f"Failed to connect to Wi-Fi: {connect_result.stderr}")
            else:
                self.ui.log_message(f"Successfully connected to Wi-Fi network: {ssid}")

            # Retry verification up to 3 times
            for attempt in range(3):
                time.sleep(5)  # Wait for the connection to stabilize
                verify_command = 'netsh wlan show interfaces'
                verify_result = subprocess.run(verify_command, capture_output=True, text=True, shell=True)
                if ssid in verify_result.stdout:
                    self.ui.log_message(f"Verified: Connected to Wi-Fi network: {ssid}")
                    return  # Exit the method if verification succeeds
                else:
                    self.ui.log_message(f"Verification failed (Attempt {attempt + 1}/3): Not connected to Wi-Fi network: {ssid}")
                    if attempt < 2:
                        self.ui.log_message("Retrying connection...")
                        subprocess.run(connect_command, capture_output=True, text=True, shell=True)

            # If all attempts fail
            self.ui.log_message(f"Failed to connect to Wi-Fi network: {ssid} after 3 attempts.")
        except Exception as e:
            self.ui.log_message(f"Error during Wi-Fi connection setup: {e}")
        finally:
            # Clean up the temporary file
            if os.path.exists(profile_path):
                os.remove(profile_path)
    
    def ping_server_l(self, server):
        try:
            ping_count = self.ui.txtpings.toPlainText()  # Get the value from txtpings
            output = subprocess.check_output(['ping', '-n', ping_count, server], stderr=subprocess.STDOUT, universal_newlines=True,creationflags=subprocess.CREATE_NO_WINDOW)
            loss_match = re.search(r'(\d+)% loss', output)
            avg_match = re.search(r'Average = (\d+)ms', output)
            loss = int(loss_match.group(1)) if loss_match else None
            avg = int(avg_match.group(1)) if avg_match else None

            if server in self.server_standards_l:
                loss_standard = self.server_standards_l[server]['loss']
                avg_standard = self.server_standards_l[server]['avg']
            else:
                return (server, False, f"No standards defined for {server}")

            # Perform comparisons
            loss_status = "OK" if loss is not None and loss <= loss_standard else "Fail"
            avg_status = "OK" if avg is not None and avg <= avg_standard else "Fail"

            # Only log the final result
            result = f"{server}: Loss: {loss}%, Average: {avg}ms - Status: Loss Status = {loss_status}, Average Status = {avg_status}"
            return (server, loss_status == "OK" and avg_status == "OK", result)
        except subprocess.CalledProcessError:
            return (server, False, f"{server} is not reachable.")
    def ping_servers_concurrently_l(self, servers):
        all_ok = True  
        results = []
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = {executor.submit(self.ping_server_l, server): server for server in servers}
            for future in concurrent.futures.as_completed(futures):
                server, is_ok, result = future.result()  
                results.append(result)
                if not is_ok:
                    all_ok = False     
        # Log only the final results
        self.ui.log_message("\n".join(results))
        if all_ok:
            self.ui.log_message("\nKết luận: Tất cả các server đều đạt yêu cầu (OK).")
        else:
            self.ui.log_message("\nKết luận: Có ít nhất một server không đạt yêu cầu (Not OK).")
        return all_ok


    def get_unique_file_path(self,output_path, output_file_name):
        base_name, extension = os.path.splitext(output_file_name)
        counter = 1
        new_file_name = output_file_name
        while os.path.exists(os.path.join(output_path, new_file_name)):
            new_file_name = f"{base_name} ({counter}){extension}"
            counter += 1
        return os.path.join(output_path, new_file_name)

    @staticmethod
    def start_idm_download(idm_path, download_url, output_path, output_file_name):
        command = [
            idm_path,
            "/d", download_url,
            "/p", output_path,
            "/f", output_file_name,
            "/q",  
            "/n",  
        ]
        try:
            return subprocess.Popen(command)
        except Exception as e:
            print(f"Error starting IDM: {e}")
            return None

    def monitor_network_speed(self, speeds, stop_event, interval=1):
        self.ui.log_message("Monitoring download speed:")
        try:
            while not stop_event.is_set():
                bytes_received_before = psutil.net_io_counters().bytes_recv
                time.sleep(interval)
                bytes_received_after = psutil.net_io_counters().bytes_recv
                speed_bps = (bytes_received_after - bytes_received_before) / interval
                speed_mbps = (speed_bps * 8) / (1000 * 1000)
                if speed_mbps > 0:  # Chỉ ghi nhận tốc độ lớn hơn 0
                    self.ui.log_message(f"Download speed: {speed_mbps:.2f} Mbps")
                    speeds.append(speed_mbps)
        except Exception as e:
            print(f"An error occurred while monitoring speed: {e}")
    def stop_idm_process(self):
        for proc in psutil.process_iter(['pid', 'name']):
            if (proc.info['name'] == 'IDMan.exe'):  
                try:
                    proc.terminate()  
                    self.ui.log_message(f"Terminated IDM process (PID: {proc.info['pid']})")
                except psutil.NoSuchProcess:
                    self.ui.log_message(f"Process {proc.info['pid']} already terminated.")
                except Exception as e:
                    self.ui.log_message(f"Error terminating IDM process: {e}")
    @property
    def fileidm2(self):
        """Trả về đường dẫn được chuẩn hóa từ UI."""
        return os.path.normpath(self.ui.fileIDM.text())
    @property
    def download_url(self):
        """Trả về đường dẫn được chuẩn hóa từ UI."""
        return self.ui.linkdown.text()  # Ensure this is a valid URL

    
    def calculate_average_speed(self,speeds):
        if (speeds):
            avg_speed = statistics.mean(speeds)
            self.ui.log_message(f"Average download speed: {avg_speed:.2f} Mbps")
            return avg_speed
        return 0

    def delete_directory_contents(self,directory_path):
        try:
            if (os.path.exists(directory_path) and os.path.isdir(directory_path)):
                for filename in os.listdir(directory_path):
                    file_path = os.path.join(directory_path, filename)
                    try:
                        if (os.path.isdir(file_path)):
                            shutil.rmtree(file_path)
                        else:
                            os.remove(file_path)
                        self.ui.log_message(f"Đã xóa: {file_path}")
                    except Exception as e:
                        self.ui.log_message(f"Không thể xóa {file_path}: {e}")
            else:
                self.ui.log_message(f"Thư mục {directory_path} không tồn tại hoặc không phải là thư mục hợp lệ.")
        except Exception as e:
            self.ui.log_message(f"Đã xảy ra lỗi khi xóa dữ liệu trong thư mục: {e}")
    def run_download_cycle(self, idm_path, download_url, output_path, standard_speed):
        stop_event = threading.Event()
        avg_speed = None  
        for attempt in range(3): 
            self.ui.log_message(f"\nAttempt {attempt + 1}/3")  # Log attempt number
            try:
                stop_event = threading.Event()
                full_path = self.get_unique_file_path(output_path, os.path.basename(download_url))
                self.ui.log_message(f"Download path: {full_path}")  # Log file path
                idm_process = self.start_idm_download(idm_path, download_url, output_path, os.path.basename(full_path))
                if idm_process is None:
                    self.ui.log_message("Failed to start IDM download.")
                    return 0
                
                speeds = []
                monitoring_thread = threading.Thread(target=self.monitor_network_speed, args=(speeds, stop_event))
                monitoring_thread.start()
                self.ui.log_message("Running IDM for 90 seconds...")
                time.sleep(90)  # Wait for 120 seconds
                self.ui.log_message("Terminating IDM after 90 seconds...")
                self.stop_idm_process()
                stop_event.set() 
                monitoring_thread.join()
                avg_speed = self.calculate_average_speed(speeds)

                if avg_speed < standard_speed:
                    self.ui.log_message(f"Speed is below the standard ({standard_speed} Mbps). Average download speed: {avg_speed:.2f} Mbps")
                    avg_speed = round(avg_speed, 2)  # Round to 2 decimal places
                    if attempt == 2:
                        self.ui.log_message("Failing the entire cycle. Speed too low.")
                        self.result_download = "Fail"
                        return avg_speed  # Return avg_speed when attempt == 2
                    else:
                        self.ui.log_message("Trying again in the next attempt.")
                        self.result_download = "Fail"
                        return avg_speed  # Log avg_speed even if below standard
                else:
                    self.ui.log_message(f"Speed is above or equal to the standard ({standard_speed} Mbps). Average download speed: {avg_speed:.2f} Mbps.")
                    self.result_download = "OK"
                    avg_speed = round(avg_speed, 2)  # Round to 2 decimal places
                    break 
            except Exception as e:
                self.ui.log_message(f"An unexpected error occurred: {e}") 
                return avg_speed     
        self.ui.log_message("Cleanup completed.")

        return avg_speed


    def main_l(self):
        self.ui.log_message("Lần kiểm tra thứ 1:")
        all_ok = self.ping_servers_concurrently_l(self.servers)    
        if (all_ok):
            self.ui.log_message("\nTất cả các server đều OK.")
            return "OK"
        self.ui.log_message("\nLần kiểm tra thứ 2:")
        all_ok = self.ping_servers_concurrently_l(self.servers)
        if (all_ok):
            self.ui.log_message("\nTất cả các server đều OK ở lần 2. Tiếp tục kiểm tra lần 3.")
        else:
            self.ui.log_message("\nKiểm tra ping fail. Kết thúc chương trình.")
            return "Fail"
        self.ui.log_message("\nLần kiểm tra thứ 3:")
        all_ok = self.ping_servers_concurrently_l(self.servers)
        if (all_ok):
            self.ui.log_message("\nTất cả các server đều OK ở lần 3.")
            return "OK"
        else:
            self.ui.log_message("\nKiểm tra ping lần thứ ba fail. Kết thúc chương trình.")
            return "Fail" 

    def run_multiple_tests_l(self):
        result_1 = result_2 = result_3 = None
        self.ui.log_message(f"\nKiểm tra ping lần 1:")
        result_1 = self.main_l()
        self.ui.log_message(f"\nKiểm tra ping lần 2:")
        result_2 = self.main_l()
        self.ui.log_message(f"\nKiểm tra ping lần 3:")
        result_3 = self.main_l()

        return result_1, result_2, result_3
    
    def run_multiple_tests_w(self):
        result_1 = result_2 = result_3 = None
        self.ui.log_message(f"\nKiểm tra ping lần 1:")
        result_1 = self.main_w()  
        self.ui.log_message(f"\nKiểm tra ping lần 2:")
        result_2 = self.main_w() 
        self.ui.log_message(f"\nKiểm tra ping lần 3:")
        result_3 = self.main_w()  
    
        return result_1, result_2, result_3


    
    def ping_server_w(self, server):
        try:
            ping_count = self.ui.txtpings.toPlainText()  # Get the value from txtpings
            output = subprocess.check_output(['ping', '-n', ping_count, server], stderr=subprocess.STDOUT, universal_newlines=True,creationflags=subprocess.CREATE_NO_WINDOW)
            loss_match = re.search(r'(\d+)% loss', output)
            avg_match = re.search(r'Average = (\d+)ms', output)
            loss = int(loss_match.group(1)) if loss_match else None
            avg = int(avg_match.group(1)) if avg_match else None
            if (server in self.server_standards_w):
                loss_standard = self.server_standards_w[server]['loss']
                avg_standard = self.server_standards_w[server]['avg']
            else:
                return (server, False, f"No standards defined for {server}")
            loss_status = "OK" if loss is not None and loss <= loss_standard else "Fail"
            avg_status = "OK" if avg is not None and avg <= avg_standard else "Fail"
            result = f"{server}: Loss: {loss}%, Average: {avg}ms"
            result += f" - Status: Loss Status = {loss_status}, Average Status = {avg_status}"
            return (server, loss_status == "OK" and avg_status == "OK", result)
        except subprocess.CalledProcessError:
            return (server, False, f"{server} is not reachable.")

    def ping_servers_concurrently_w(self, servers):
        all_ok = True
        results = []
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = {executor.submit(self.ping_server_w, server): server for server in servers}
            for future in concurrent.futures.as_completed(futures):
                server, is_ok, result = future.result()
                results.append(result)
                if not is_ok:
                    all_ok = False

        # Log only the final results once
        self.ui.log_message("\n".join(results))
        if all_ok:
            self.ui.log_message("Kết luận: Tất cả các server đều đạt yêu cầu (OK).")
        else:
            self.ui.log_message("Kết luận: Có ít nhất một server không đạt yêu cầu (Not OK).")
        return all_ok

    def main_w(self):
        for attempt in range(1, 4):  # Loop for 3 attempts
            self.ui.log_message(f"Lần kiểm tra thứ {attempt}:")
            all_ok = self.ping_servers_concurrently_w(self.servers)
            if all_ok:
                self.ui.log_message(f"Tất cả các server đều OK ở lần {attempt}.")
                return "OK"
            elif attempt < 3:
                self.ui.log_message(f"Kiểm tra ping lần {attempt} thất bại. Thử lại...")
            else:
                self.ui.log_message("Kiểm tra ping thất bại sau 3 lần thử. Kết thúc chương trình.")
                return "Fail"
        
    
    
    def check_lost_frames(self, urls_to_test):
        lost_frames_final = {url: 0 for url in urls_to_test}  
        players = []

        for url in urls_to_test:
            instance = vlc.Instance()
            player = instance.media_player_new()
            media = instance.media_new(url)
            player.set_media(media)
            players.append((player, url))
            
        for player, url in players:
            player.play()
            time.sleep(2)  # Đợi một chút để trình phát chuyển trạng thái
            if player.get_state() == vlc.State.Playing:
                self.successful_urls += 1  # Tăng biến đếm nếu URL được mở thành công
                self.ui.log_message(f"URL mở thành công: {url}")
            else:
                self.ui.log_message(f"URL không mở được: {url}")
                
        time.sleep(15)  # Đợi thêm thời gian để kiểm tra frames lost

        # Tiếp tục logic kiểm tra frames lost
        initial_displayed_pictures = {}
        frames_lost = {}
        for player, url in players:
            stats = vlc.MediaStats()
            player.get_media().get_stats(stats)
            initial_displayed_pictures[url] = stats.displayed_pictures
            frames_lost[url] = stats.lost_pictures

        start_time = time.time()
        while (time.time() - start_time < 300):  # Thời gian kiểm tra 300 giây
            for player, url in players:
                if player.get_state() == vlc.State.Playing:
                    stats = vlc.MediaStats()
                    player.get_media().get_stats(stats)
                    current_lost = stats.lost_pictures
                    if current_lost > frames_lost[url]:
                        frames_lost[url] = current_lost
                        lost_frames_final[url] = current_lost
                        self.ui.log_message(f"[{url}] Tổng frames lost: {lost_frames_final[url]}")
            time.sleep(1)

        for player, url in players:
            player.stop()

        self.ui.log_message(f"Tổng số URL mở thành công: {self.successful_urls}")
        return lost_frames_final

    def check_conclusion(self,urls_to_test):
        lost_frames = self.check_lost_frames(urls_to_test)
        lost_frames_str = {url: f"Lost Frames: {lost_frames[url]}" for url in lost_frames}
        
        if (all(frames < 1 for frames in lost_frames.values())):
            self.ui.log_message("Kết luận: OK (Lần 1)")  
            return lost_frames_str  
        else:
            self.ui.log_message("Lần 1: Tổng frames lost lớn hơn 1, thử lại lần 2...")
            lost_frames = self.check_lost_frames(urls_to_test)
            self.ui.log_message(f"Lần 2: {lost_frames}")  
            
            if (any(frames > 1 for frames in lost_frames.values())):
                self.ui.log_message("Kết luận: Fail (Lần 2)")
            else:
                self.ui.log_message("Lần 2: Tổng frames lost nhỏ hơn hoặc bằng 1, thử lại lần 3...")
                lost_frames = self.check_lost_frames(urls_to_test)
                self.ui.log_message(f"Lần 3: {lost_frames}") 
                
                if (all(frames < 1 for frames in lost_frames.values())):
                    self.ui.log_message("Kết luận: OK (Lần 3)")
                else:
                    self.ui.log_message("Kết luận: Fail (Lần 3)")
                
        return lost_frames_str
    
    def stop_test(self):
        self.ui.log_message("Test đã bị dừng.")
        # Add any additional cleanup logic here if needed
        raise Exception("Test stopped by user or due to an error.")

    def disable_wifi(self):
        result = subprocess.run('netsh interface set interface "Wi-Fi" disable', capture_output=True, text=True, shell=True)
        if (result.returncode != 0):
            self.ui.log_message(f"Lỗi khi tắt Wi-Fi: {result.stderr}")
        else:
            self.ui.log_message("Wi-Fi đã được tắt.")
    def check_results(self, ping, dow):
        if (ping == "OK" and dow == "OK"):
            return "OK"
        else:
            self.concludeLan = "Fail"
            return "Fail"
    def remove_existing_mac(self, mac_address):
        json_file_path='results_data.json'
        if not os.path.exists(json_file_path):
            print(f"File {json_file_path} không tồn tại.")
            return            # Đọc dữ liệu từ tệp JSON
        with open(json_file_path, 'r', encoding='utf-8') as json_file:
            data = json.load(json_file)

        # Lọc bỏ các mục có địa chỉ MAC trùng khớp
        updated_data = [entry for entry in data if entry.get("MAC Address") != mac_address]
        self.full_data = Full_data(self, self.test_data_table)  # Pass test_data_table to Full_data

        self.full_data.setup_test_data_table()
        # Ghi lại dữ liệu đã cập nhật vào tệp JSON
        with open(json_file_path, 'w', encoding='utf-8') as json_file:
            json.dump(updated_data, json_file, ensure_ascii=False, indent=4)

        self.ui.log_message(f"Đã xóa các mục có địa chỉ MAC {mac_address}.")
    def test5G(self):
        self.ui.log_message("\nKiểm tra 5G:")
        ssid = self.ui.ESSID_text.toPlainText() + '5'  # Access through self.ui
        password = self.ui.PreSharedKey_text.toPlainText()  # Access through self.ui
        self.disable_network_adapter("Ethernet")
        time.sleep(5)
        self.disable_network_adapter("Wi-Fi")
        time.sleep(5)
        self.enable_wifi()
        time.sleep(10)
        self.connect_wifi(ssid, password)
        time.sleep(10)

        time.sleep(5)
        standard_speed = int(self.ui.txtTC5G.text()) if self.ui.txtTC5G.text().strip() else 0   # Tiêu chuẩn download WIFI 5GHz (Mbps)
        # Use the retrieved text values for IDM path, download URL, and output path
        self.ui.log_message(f"down URl: {self.download_url}")
        download_speed_1 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(3, 7, QtWidgets.QTableWidgetItem(str(download_speed_1)))
        self.ui.Table_wf.item(3, 7).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        download_speed_2 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(4, 7, QtWidgets.QTableWidgetItem(str(download_speed_2)))
        self.ui.Table_wf.item(4, 7).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        download_speed_3 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(5, 7, QtWidgets.QTableWidgetItem(str(download_speed_3)))
        self.ui.Table_wf.item(5, 7).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa

        time.sleep(5)
        result_1, result_2, result_3 = self.run_multiple_tests_w()
        if (result_1 == "OK" and result_2 == "OK" and result_3 == "OK"):
            self.result_ping = "OK"
            self.ui.log_message("\nTất cả các server đều OK.")
            # Write results to the "Wifi Ping time" column
            self.ui.Table_wf.setItem(3, 5, QtWidgets.QTableWidgetItem(result_1))
            self.ui.Table_wf.item(3, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(4, 5, QtWidgets.QTableWidgetItem(result_2))
            self.ui.Table_wf.item(4, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(5, 5, QtWidgets.QTableWidgetItem(result_3))
            self.ui.Table_wf.item(5, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            if(self.result_download == "OK"):
                self.concludeWIFI5 = "OK"
            else:
                self.concludeWIFI5 = "Fail"
        else:
            self.ui.Table_wf.setItem(3, 5, QtWidgets.QTableWidgetItem(result_1))
            self.ui.Table_wf.item(3, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(4, 5, QtWidgets.QTableWidgetItem(result_2))
            self.ui.Table_wf.item(4, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(5, 5, QtWidgets.QTableWidgetItem(result_3))
            self.ui.Table_wf.item(5, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.log_message("\nCó ít nhất một server không đạt yêu cầu (Not OK).")
       
        check_reconnect = lambda r1, r2, r3: "OK" if all(r is not None and r != "" for r in [r1, r2, r3]) else "Fail"
        check_conclusion = lambda download_result, reconnect_result: "OK" if download_result == "OK" and reconnect_result == "OK" else "Fail"

        self.results_data.append({
            "MAC Address": self.mac_address,
            "Connection Type": "5G",
            "Ping Result 1": result_1,
            "Ping Result 2": result_2,
            "Ping Result 3": result_3,
            "Download Speed 1 (Mbps)": download_speed_1,
            "Download Speed 2 (Mbps)": download_speed_2,
            "Download Speed 3 (Mbps)": download_speed_3,
            "Download Result": self.result_download,
            "Final conclusion": check_conclusion(self.result_download, check_reconnect(result_1, result_2, result_3))
        })

        self.ui.log_message("5G test completed.")

        
    def test24G(self):
        self.ui.log_message("\nKiểm tra 2.4G:")
        ssid = self.ui.ESSID_text.toPlainText() + '2'  # Access through self.ui
        password = self.ui.PreSharedKey_text.toPlainText()   
        self.disable_network_adapter("Ethernet")
        time.sleep(5)
        self.disable_network_adapter("Wi-Fi")
        time.sleep(5)
        self.enable_wifi()
        time.sleep(10)
        self.connect_wifi(ssid, password)
        time.sleep(10)
        standard_speed = int(self.ui.txtTC2G.text()) if self.ui.txtTC2G.text().strip() else 0   # Tiêu chuẩn download WIFI 2.4GHz (Mbps)
        self.ui.log_message(f"down URl: {self.download_url}")
        download_speed_1 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(3, 6, QtWidgets.QTableWidgetItem(str(download_speed_1)))
        self.ui.Table_wf.item(3, 6).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        time.sleep(5)
        download_speed_2 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(4, 6, QtWidgets.QTableWidgetItem(str(download_speed_2)))
        self.ui.Table_wf.item(4, 6).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        time.sleep(5)
        download_speed_3 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(5, 6, QtWidgets.QTableWidgetItem(str(download_speed_3)))
        self.ui.Table_wf.item(5, 6).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        time.sleep(5)
        self.delete_directory_contents(self.ui.outputFile.text())  # đường dẫn lưu

        result_1, result_2, result_3 = self.run_multiple_tests_w()
        if (result_1 == "OK" and result_2 == "OK" and result_3 == "OK"):
            self.result_ping = "OK"
            self.ui.log_message("\nTất cả các server đều OK.")
            # Write results to the "Wifi Ping time" column
            self.ui.Table_wf.setItem(3, 5, QtWidgets.QTableWidgetItem(result_1))
            self.ui.Table_wf.item(3, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(4, 5, QtWidgets.QTableWidgetItem(result_2))
            self.ui.Table_wf.item(4, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(5, 5, QtWidgets.QTableWidgetItem(result_3))
            self.ui.Table_wf.item(5, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            if(self.result_download == "OK"):
                self.concludeWIFI2 = "OK"
            else:
                self.concludeWIFI2 = "Fail"
        else:
            self.ui.Table_wf.setItem(3, 5, QtWidgets.QTableWidgetItem(result_1))
            self.ui.Table_wf.item(3, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(4, 5, QtWidgets.QTableWidgetItem(result_2))
            self.ui.Table_wf.item(4, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(5, 5, QtWidgets.QTableWidgetItem(result_3))
            self.ui.Table_wf.item(5, 5).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.log_message("\nCó ít nhất một server không đạt yêu cầu (Not OK).")
            self.concludeWIFI = "Fail"        # Lambda function to check if all results are valid
        check_reconnect = lambda r1, r2, r3: "OK" if all(r is not None and r != "" for r in [r1, r2, r3]) else "Fail"
        check_conclusion = lambda download_result, reconnect_result: "OK" if download_result == "OK" and reconnect_result == "OK" else "Fail"
        if self.concludeWIFI5 == "OK" and self.concludeWIFI2 == "OK" and self.concludeLan == "OK":
            self.concludeAll = "OK"
        else:
            self.concludeAll = "Fail"
        for i in range(3):
            self.ui.Table_wf.setItem(i+3, 10, QtWidgets.QTableWidgetItem(self.concludeAll))
            self.ui.Table_wf.item(i+3, 10).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa

        self.results_data.append({
            "MAC Address": self.mac_address,
            "Connection Type": "2.4G",
            "Ping Result 1": result_1,
            "Ping Result 2": result_2,
            "Ping Result 3": result_3,
            "Download Speed 1 (Mbps)": download_speed_1,
            "Download Speed 2 (Mbps)": download_speed_2,
            "Download Speed 3 (Mbps)": download_speed_3,
            "Download Result": self.result_download,
            "Final conclusion": check_conclusion(self.result_download, check_reconnect(result_1, result_2, result_3)),
            "Conclude All": self.concludeAll
        })
        
        self.ui.log_message("2.4G test completed.")
    def display_server_standards_l(self):
        """Hiển thị thông tin server_standards_l trong log."""
        self.ui.log_message("Hiển thị tiêu chuẩn kiểm tra (server_standards_l):")
        for server, standards in self.server_standards_l.items():
            loss_standard = standards['loss']
            avg_standard = standards['avg']
            self.ui.log_message(f"Server: {server}, Loss Standard: {loss_standard}, Avg Standard: {avg_standard}")
    def update_server_standards_l(self):
        gateway_ip = self.get_gateway()
        self.servers = [gateway_ip, self.ui.pgoogle.text(), self.ui.p24.text(), self.ui.pfpt.text()]
        self.server_standards_l = {
            gateway_ip: {'loss': int(self.ui.txtLSgate.text()), 'avg': int(self.ui.txtAGgate.text())},
            self.ui.pgoogle.text(): {'loss': int(self.ui.txtLSgool.text()), 'avg':int(self.ui.txtAGgool.text())},
            self.ui.p24.text(): {'loss': int(self.ui.txtLS24.text()), 'avg': int(self.ui.txtAG24.text())},
            self.ui.pfpt.text(): {'loss': int(self.ui.txtLSFPT.text()), 'avg': int(self.ui.txtAGFPT.text())}
        }
        
        self.server_standards_w = {
            gateway_ip: {'loss': int(self.ui.txtWiFiLSgate.text()), 'avg': int(self.ui.txtWiFiAGgate.text())},
            self.ui.pgoogle.text(): {'loss': int(self.ui.txtWiFiLSgool.text()), 'avg': int(self.ui.txtWiFiAGgool.text())},
            self.ui.p24.text(): {'loss': int(self.ui.txtWiFiLS24.text()), 'avg': int(self.ui.txtWiFiAG24.text())},
            self.ui.pfpt.text(): {'loss': int(self.ui.txtWiFiLSFPT.text()), 'avg': int(self.ui.txtWiFiAGFPT.text())}
        }

    def check_multiple(self):
        if self.successful_urls >=2:
            return "OK"
        else:
            return "Fail"
        
    def testLan(self):       
        self.ui.log_message("\nKiểm tra LAN:")
        self.disable_wifi()
        self.disable_network_adapter("Ethernet")
        self.check_and_enable_ethernet()
        time.sleep(10)
        with open("results_data.json", 'r', encoding='utf-8') as json_file:
            data = json.load(json_file)

        # Kiểm tra xem địa chỉ MAC có trong danh sách không
        for entry in data:
            if entry.get("MAC Address") == self.mac_address:
                self.remove_existing_mac(self.mac_address)
                time.sleep(2)
                continue
        
        time.sleep(5)
        self.update_server_standards_l()
        self.display_server_standards_l
        self.ui.log_message(f"Test Ping...")
        check_reconnect = lambda r1, r2, r3: "OK" if all(r is not None and r != "" for r in [r1, r2, r3]) else "Fail"
        check_conclusion2 = lambda download_result, reconnect_result: "OK" if download_result == "OK" and reconnect_result == "OK" else "Fail"
        result_1, result_2, result_3 = self.run_multiple_tests_l()
        if (result_1 == "OK" and result_2 == "OK" and result_3 == "OK"):
            self.result_ping = "OK"
            self.ui.log_message("\nTất cả các server đều OK.")
            # Write results to the "Wifi Ping time" column
            self.ui.Table_wf.setItem(3, 3, QtWidgets.QTableWidgetItem(result_1))
            self.ui.Table_wf.item(3, 3).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(4, 3, QtWidgets.QTableWidgetItem(result_2))
            self.ui.Table_wf.item(4, 3).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(5, 3, QtWidgets.QTableWidgetItem(result_3))
            self.ui.Table_wf.item(5, 3).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        else:
            self.result_ping = "Fail"
            self.ui.Table_wf.setItem(3, 3, QtWidgets.QTableWidgetItem(result_1))
            self.ui.Table_wf.item(3, 3).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(4, 3, QtWidgets.QTableWidgetItem(result_2))
            self.ui.Table_wf.item(4, 3).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(5, 3, QtWidgets.QTableWidgetItem(result_3))
            self.ui.Table_wf.item(5, 3).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.log_message("\nCó ít nhất một server không đạt yêu cầu (Not OK).")
        time.sleep(10)

        self.ui.log_message(f"Test Download...")
        # Correctly retrieve the value from txtTCLan
        standard_speed = int(self.ui.txtTCLan.text()) if self.ui.txtTCLan.text().strip() else 0
        self.ui.log_message(f"stand: {self.standard_speed}")
        download_speed_1 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(3, 4, QtWidgets.QTableWidgetItem(str(download_speed_1)))
        self.ui.Table_wf.item(3, 4).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        download_speed_2 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(4, 4, QtWidgets.QTableWidgetItem(str(download_speed_2)))
        self.ui.Table_wf.item(4, 4).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        download_speed_3 = self.run_download_cycle(self.fileidm2, self.download_url, self.output_path, standard_speed)
        self.ui.Table_wf.setItem(5, 4, QtWidgets.QTableWidgetItem(str(download_speed_3)))
        self.ui.Table_wf.item(5, 4).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        if self.check_results(self.result_ping, self.result_download) == "OK":
            if self.concludeLan is None:
                self.concludeLan = "OK"
        else:
            self.concludeLan = "Fail"
        time.sleep(5)

        self.delete_directory_contents(self.ui.outputFile.text())  # đường dẫn lưu
        urls_to_test = [self.hd_url_1, self.hd_url_2, self.sd_url]
        lost_frames_str = self.check_conclusion(urls_to_test)
        for url, frame_loss in lost_frames_str.items():
            self.ui.log_message(f"{url} - {frame_loss}")  
        time.sleep(5) 
        check_lost_frames = lambda *frames: (
            "Fail" if any(int(frame.split(": ")[1]) > 1 for frame in frames if frame != "N/A") else "OK",
            "Fail" if any(int(frame.split(": ")[1]) > 2 for frame in frames if frame != "N/A") else "OK",
            "Fail" if any(int(frame.split(": ")[1]) > 3 for frame in frames if frame != "N/A") else "OK"
        )
        stability, Watch_multiple_channels, Change_channel = check_lost_frames(
            lost_frames_str.get(self.sd_url, "N/A"),
            lost_frames_str.get(self.hd_url_2, "N/A"),
            lost_frames_str.get(self.hd_url_1, "N/A")
        )
        for i in range(3):
            self.ui.Table_wf.setItem(i + 3, 8, QtWidgets.QTableWidgetItem(stability))
            self.ui.Table_wf.item(i + 3, 8).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
            self.ui.Table_wf.setItem(i + 3, 9, QtWidgets.QTableWidgetItem(self.check_multiple()))
            self.ui.Table_wf.item(i + 3, 9).setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)  # Căn lề giữa
        
        self.results_data.append({
        "MAC Address": self.mac_address,
        "Connection Type": "LAN",
        "Ping Result 1": result_1,
        "Ping Result 2": result_2,
        "Ping Result 3": result_3,
        "Download Speed 1 (Mbps)": download_speed_1,
        "Download Speed 2 (Mbps)": download_speed_2,
        "Download Speed 3 (Mbps)": download_speed_3,
        "Download Result": self.result_download,
        "Stability": stability,
        "Watch multiple channels": self.check_multiple(),
        "Final conclusion": check_conclusion2(self.result_download, check_reconnect(result_1, result_2, result_3)),
        "Tx Power" : self.Tx_Power	
        })
    
    
    def testAll(self):
        """Run all tests (LAN, 5G, 2.4G) and save results to a JSON file."""
        try:
            # Reset results and variables
            self.results_data = []
            self.concludeLan = ""
            self.concludeWIFI5 = ""
            self.concludeWIFI2 = ""
            self.result_ping = None
            self.result_download = None

            mac = self.mac_address
            if not mac:
                self.ui.log_message("Unable to retrieve MAC address. Aborting tests.")
                return

            # Run individual tests
            self.testLan()
            self.test5G()
            self.test24G()

            # Load existing results or initialize an empty list
            existing_data = []
            if os.path.exists('results_data.json'):
                with open('results_data.json', 'r', encoding='utf-8') as json_file:
                    existing_data = json.load(json_file)

            # Append new results and save back to the file
            existing_data.extend(self.results_data)
            with open('results_data.json', 'w', encoding='utf-8') as json_file:
                json.dump(existing_data, json_file, ensure_ascii=False, indent=4)

            self.ui.log_message("Results data has been successfully saved to results_data.json.")
        except Exception as e:
            self.ui.log_message(f"An error occurred during the test process: {e}")
        finally:
            self.ui.log_message("Test process completed.")

    def config_testAll(self):
        """Configure the system and run all tests."""
        try:
            self.configure()
            time.sleep(10)
            self.testAll()
            self.check_and_enable_ethernet()
            self.ui.export_to_excel()
        except Exception as e:
            self.ui.log_message(f"An error occurred during configuration or testing: {e}")
            self.check_and_enable_ethernet()


if __name__ == "__main__":
    import sys
    def handle_exception(exc_type, exc_value, exc_traceback):
        if issubclass(exc_type, KeyboardInterrupt):
            sys.__excepthook__(exc_type, exc_value, exc_traceback)
            return
        with open("error.log", "a", encoding="utf-8") as log_file:
            log_file.write("".join(traceback.format_exception(exc_type, exc_value, exc_traceback)))
        print(f"Unhandled exception: {exc_value}")

    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.excepthook = handle_exception
    sys.exit(app.exec())
